<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sensor Chart</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { height: 100%; display: flex; flex-direction: column; }

    .bar{
      padding: 10px;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      border-bottom: 1px solid #e5e7eb;
    }
    .btn{
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      background: #fff;
      cursor: pointer;
      font-weight: 600;
    }
    .btn.active{
      border-color:#111827;
      background:#111827;
      color:#fff;
    }
    .hint{
      margin-left: auto;
      font-weight: 700;
      color: #111827;
      white-space: nowrap;
    }

    .canvas-wrap{
      flex: 1;
      padding: 10px;
      box-sizing: border-box;
      position: relative;
    }
    canvas{ width: 100% !important; height: 100% !important; }

    .no-data{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:#fff;
    }
    .no-data img{ max-width: 55%; opacity: 0.9; }
  </style>
</head>

<body>
<div class="wrap">
  <div class="bar">
    <button class="btn" id="btnMonth">Tháng</button>
    <button class="btn" id="btnWeek">Tuần</button>
    <button class="btn" id="btnDay">Ngày</button>
    <button class="btn" id="btnHour">Giờ</button>
    <button class="btn" id="btnMinute">Phút</button>
    <button class="btn" id="btnNow">Hiện tại</button>
    <div class="hint" id="hint"></div>
  </div>

  <div class="canvas-wrap">
    <canvas id="chart"></canvas>
    <div class="no-data" id="noData">
      <img src="no_data.png" alt="No data">
    </div>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import { getDatabase, ref, get } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

  // ✅ sửa firebaseConfig của bạn
  const firebaseConfig = {
    apiKey: "YOUR_API_KEY",
    authDomain: "YOUR_PROJECT.firebaseapp.com",
    databaseURL: "https://iot-mg-default-rtdb.firebaseio.com",
    projectId: "YOUR_PROJECT_ID",
    appId: "YOUR_APP_ID",
  };

  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);

  // ========= URL: ?id=<sensorKey> =========
  const params = new URLSearchParams(location.search);
  const SENSOR_ID = (params.get("id") || "").trim();  // ví dụ Humidity_gr_sensor

  if (!SENSOR_ID) {
    document.body.innerHTML =
      "<div style='padding:14px;font-family:system-ui'>Thiếu sensor id. Ví dụ: <b>?id=Humidity_gr_sensor</b></div>";
    throw new Error("Missing sensor id");
  }

  // Hiển thị tên sensor trên thanh
  document.getElementById("hint").textContent = SENSOR_ID;

  const ROOT = "DataGarden/Sensor";
  const noDataEl = document.getElementById("noData");
  const canvasEl = document.getElementById("chart");

  function showNoData(show){
    noDataEl.style.display = show ? "flex" : "none";
    canvasEl.style.display = show ? "none" : "block";
  }

  // ========= time helpers =========
  const pad2 = n => String(n).padStart(2,"0");

  function parseKeyToDate(key){
    // yyyy-MM-dd-hh-mm-ss
    const parts = key.split("-").map(x => parseInt(x,10));
    if (parts.length !== 6 || parts.some(Number.isNaN)) return null;
    const [y, mo, d, h, mi, s] = parts;
    return new Date(y, mo-1, d, h, mi, s);
  }

  function toNumber(val){
    if (val === null || val === undefined) return null;
    const s = String(val).replace(/"/g,"").trim();
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  }

  function isoWeek(date) {
    const dt = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const dayNum = dt.getUTCDay() || 7;
    dt.setUTCDate(dt.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(dt.getUTCFullYear(), 0, 1));
    const week = Math.ceil((((dt - yearStart) / 86400000) + 1) / 7);
    return { week, weekYear: dt.getUTCFullYear() };
  }

  function bucketKey(mode, dt){
    const y = dt.getFullYear();
    const m = pad2(dt.getMonth()+1);
    const d = pad2(dt.getDate());
    const h = pad2(dt.getHours());
    const mi= pad2(dt.getMinutes());

    if (mode === "minute") return `${y}-${m}-${d}-${h}-${mi}`; // YYYY-MM-DD-hh-mm
    if (mode === "hour")   return `${y}-${m}-${d}-${h}`;       // YYYY-MM-DD-hh
    if (mode === "day")    return `${y}-${m}-${d}`;            // YYYY-MM-DD
    if (mode === "month")  return `${y}-${m}`;                 // YYYY-MM
    const { week, weekYear } = isoWeek(dt);
    return `${weekYear}-W${pad2(week)}`;                       // YYYY-Wxx
  }

  function labelForMode(mode, dt){
    const y2 = String(dt.getFullYear()).slice(-2);
    const m  = pad2(dt.getMonth()+1);
    const d  = pad2(dt.getDate());
    const h  = pad2(dt.getHours());
    const mi = pad2(dt.getMinutes());

    if (mode === "minute") return `${d}/${m} ${h}:${mi}`;   // dd/MM hh:mm
    if (mode === "hour")   return `${d}/${m} ${h}h`;        // dd/MM hh
    if (mode === "day")    return `${d}/${m}`;              // dd/MM
    if (mode === "month")  return `${m}/${y2}`;             // MM/YY
    const { week, weekYear } = isoWeek(dt);
    const wy2 = String(weekYear).slice(-2);
    return `W${pad2(week)}/${wy2}`;                         // Wxx/YY
  }

  // ========= load series =========
  async function loadSensorSeries(){
    const datePath = `${ROOT}/${SENSOR_ID}/Date`;
    const snap = await get(ref(db, datePath));
    if (!snap.exists()) return [];

    const obj = snap.val();
    const pts = Object.entries(obj).map(([k,v]) => {
      const dt = parseKeyToDate(k);
      const val= toNumber(v);
      if (!dt || val === null) return null;
      return { t: dt, v: val };
    }).filter(Boolean);

    pts.sort((a,b)=>a.t-b.t);
    return pts;
  }

  async function loadCurrentValue(){
    // ưu tiên nếu node SENSOR_ID có value trực tiếp (không phải object)
    const snap = await get(ref(db, `${ROOT}/${SENSOR_ID}`));
    if (snap.exists()){
      const v = snap.val();
      if (typeof v === "number" || typeof v === "string"){
        const n = toNumber(v);
        if (n !== null) return n;
      }
      if (typeof v === "object" && v !== null && v[SENSOR_ID] !== undefined){
        const n = toNumber(v[SENSOR_ID]);
        if (n !== null) return n;
      }
    }
    // fallback: điểm cuối Date
    const series = await loadSensorSeries();
    if (series.length) return series[series.length-1].v;
    return null;
  }

  // ========= aggregate =========
  // lấy giá trị CUỐI bucket (mượt và đúng khi dữ liệu dày)
  function aggregate(points, mode){
    const map = new Map(); // bucket -> { lastT, v }
    for (const p of points){
      const bk = bucketKey(mode, p.t);
      const cur = map.get(bk);
      if (!cur || p.t > cur.lastT){
        map.set(bk, { lastT: p.t, v: p.v });
      }
    }
    // sort theo bucket key (an toàn)
    return Array.from(map.entries())
      .sort((a,b)=>a[0].localeCompare(b[0]))
      .map(([_,it]) => ({ t: it.lastT, v: it.v }));
  }

  // ========= chart =========
  const chart = new Chart(canvasEl, {
    type: "line",
    data: {
      labels: [],
      datasets: [{
        label: SENSOR_ID,
        data: [],
        tension: 0.25,
        pointRadius: 2,
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false, // ✅ tránh “giật” khi update
      plugins: {
        title: { display: false },
        legend: { display: true },
      },
      scales: {
        y: { ticks: { callback: (v)=>Number(v).toLocaleString("vi-VN") } }
      }
    }
  });

  // ========= mode buttons =========
  const btns = {
    month: document.getElementById("btnMonth"),
    week: document.getElementById("btnWeek"),
    day: document.getElementById("btnDay"),
    hour: document.getElementById("btnHour"),
    minute: document.getElementById("btnMinute"),
    now: document.getElementById("btnNow"),
  };

  let mode = "minute"; // default chi tiết
  function setActive(){
    Object.entries(btns).forEach(([k,el]) => el.classList.toggle("active", k===mode));
  }

  Object.keys(btns).forEach(k => {
    btns[k].onclick = () => { mode = k; lastSig = ""; tick(true); setActive(); };
  });
  setActive();

  // ========= smooth update (không reload toàn chart) =========
  function applyData(labels, values){
    // Nếu giống y hệt thì không update
    const sig = JSON.stringify([labels, values]);
    if (sig === appliedSig) return;
    appliedSig = sig;

    chart.data.labels = labels;
    chart.data.datasets[0].data = values;

    // ✅ update nhẹ, không reset animation
    chart.update("none");
  }

  function clearChart(){
    applyData([], []);
  }

  let lastSig = "";
  let appliedSig = "";

  async function tick(force=false){
    try{
      if (mode === "now"){
        const v = await loadCurrentValue();
        if (v === null){
          showNoData(true);
          clearChart();
          return;
        }
        showNoData(false);
        applyData(["Now"], [v]);
        return;
      }

      const series = await loadSensorSeries();

      // Điều kiện: phải có >=2 điểm gốc
      if (series.length < 2){
        showNoData(true);
        clearChart();
        return;
      }

      // chỉ update khi data thay đổi (lấy 10 điểm cuối để signature nhanh)
      const sig = JSON.stringify(series.slice(-10).map(p=>[p.t.toISOString(), p.v]));
      if (!force && sig === lastSig) return;
      lastSig = sig;

      const agg = aggregate(series, mode);
      const labels = agg.map(p => labelForMode(mode, p.t));
      const values = agg.map(p => p.v);

      // Điều kiện: sau gom vẫn phải có >=2 mốc thời gian
      if (labels.length < 2){
        showNoData(true);
        clearChart();
        return;
      }

      showNoData(false);
      applyData(labels, values);

    }catch(e){
      console.error(e);
    }
  }

  tick(true);
  setInterval(()=>tick(false), 2000);
</script>
</body>
</html>
